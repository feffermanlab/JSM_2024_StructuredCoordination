\documentclass[]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}

%opening
\title{Python Tools for the Analysis of a Graph Theoretical Dynamical System}
\author{John McAlister}

\begin{document}

\maketitle

\begin{abstract}
Here I present a set of tools written in python using the \verb*|networkx| library used for the analysis and visualization of a graph theoretical dynamical system inspired by a game theoretical approach to homophily. Through an object oriented approach, I investigate the dynamical system as an initial value problem then try to consider how to answer questions about a boundary value problem.
\end{abstract}

\section{Homophily though a Graph Theoretical Dynamical System}
Homophily, which is observed as the tendency to be associated with those similar to ourselves can emerge by simple mimicry behavior wherein an individual conforms to the behavior which is most common among their associates. Although this type of problem is thoroughly studied for strategies which exist in a metric space, when strategies are not measurable against one another and offer truly neutral intrinsic fitnesses, we can no longer use the standard ODE or difference equation models. Additionally, when individuals don't interact equally with all group members this game must be thought of on a graph. 
\subsection{The Game}
	Consider a connected graph $G(V,E)$ and a (not necessarily proper) vertex coloring of that graph $\mathbf{u}$ from the set of coloring $U$ which use colors in $C$. Now imagine the game where the fitness of each vertex is determined as the number of its neighbors which share the same color as it. The fitness function is $w:V\times C\times U\rightarrow \mathbb{N}$.
	For any coloring $\mathbf{u}$ (which we think of as a color vector of length equal to the number of vertices) we can calculate a best response for each vertex by finding which color would have maximized fitness given the current coloring. 
\subsection{The Dynamical System}
	If we use the best response as an update rule we get the following dynamical system
\begin{equation}
	\mathbf{u}_{k+1}=[\text{argmax}_{c\in C}\{w(v,c;\mathbf{u}_k)\} ]_{v\in V}
\end{equation}
Because argmax might be larger than a single color we have to carefully break ties. If $\mathbf{u}_{k,v}\in \text{argmax}_{c\in C}{w(v,c,\mathbf{u}_k)}$ then $\mathbf{u}_{k+1,v}=\mathbf{u}_{k,v}$. Otherwise ties are broken uniform randomly. This process results in a sequence of colorings $(\mathbf{u}_k)_{k=0}^N$ which I call an orbit. It is easy to see that equilibria of this dynamical system are Nash equilibria of the game. Some equilibria are easy to see but some are nontrivial. (Fig. 1)

\begin{figure}[h!]
	\includegraphics[width=\linewidth]{images/figure4}
	\includegraphics[width=\linewidth]{images/figure3}
	\caption{\textbf{Top} a trivial equilibrium coloring wherein every vertex has the same color. \textbf{Bottom} a nontrivial equilibrium coloring with three cliques.}
\end{figure}

Equilibria can be separated into (typically connected) subgraphs wherein each vertex has the same color called cliques. A sequence of colorings does not necessarily stop at an equilibrium. Often a two-cycle can arise (Fig. 2)

\begin{figure}[h!]
	\includegraphics[width=\linewidth]{images/figure6}
	\caption{An example of a two-cycle. If each vertex plays its best response to the coloring on the right it becomes the coloring on the left and if each vertex plays its best response to the coloring on the left it becomes the coloring on the right. }
\end{figure}

In two-cycles, we can still define cliques among the vertices which do not change. It may also become useful to discuss the connected subgraphs which alternate colors as ``two-cliques."   
\subsection{Goals}
There are several graph theoretical goals of this project, the first is to be able to find sufficient conditions and necessary conditions for equilibrium colorings. In order to do this, a process to find nontrivial equilibrium colorings is crucial. The second is to be able to classify equilibrium colorings as ``stable" or ``unstable" which requires us to have an equilibrium coloring and a way of perturbing it. Lastly we want to shift the question slightly to consider it as a boundary value problem wherein some vertices have fixed colors. It is not yet clear how to find an equilibrium coloring which satisfies the boundary condition or even how to determine if such a coloring exists. 

All of these goals require a robust set of tools for finding equilibria from an initial coloring and keeping track of an orbit through time. It will also be important to generate images and animations of orbits and equilibria. Here I present an assortment of tools towards these goals written in python using the \verb*|networkx| library. 
\section{Initial Value Problem}
The process to find equilibria can be most easy thought of as computing trajectories or orbits from an initial coloring. we conjecture, but cannot yet prove, that, despite the stochasticity of the game, every orbit ends in an equilibrium or two-cycle. Therefore the most straight forward approach to finding equilibria is to simply solve the IVP. 
\subsection{Preliminaries}
In order to begin we need a way to generate a graph, \verb*|networkx| has may functions to return well known graphs but to generate a random connected graph quickly, I wrote the function \verb*|gen_connected_graph(n,p)| which starts with an Erd\'os-R\'enyi graph on \verb*|n| vertices where the probability that any two vertices share an edge is \verb*|p|. Because considering this problem on disconnected graphs is the same as considering the problem independently for each connected component, I want to ensure that the graph I return is connected. Therefore, I make a list of connected components in the Erd\'os-R\'enyi graph and connected a random vertex in one component to a random vertex in the next component until the graph is connected. The function returns the connected graph on \verb*|n| vertices.   
\subsection{Orbit Object}
Much of the questions about the initial value problem have to do with the analysis of the sequence of colorings called an orbit. To make the analysis easier and more readable, I made a class called \verb*|Orbit| which is initialized with a graph \verb*|G|, an initial coloring \verb*|y0|, and an iteration limit required by the function which wills solve the IVP. This object has the following attributes: \verb*|Graph| which is the graph the orbit was built on, \verb*|solution| which is the sequence of colorings, \verb*|iter| which is the length of solution, \verb*|eq|, \verb*|cycle2|, \verb*|cycle3| which are boolean variables that are true if the orbit ends in an equilibrium, two-cycle, or three-cycle respectively, and \verb*|report| which is a string object describing the orbit. 
\subsubsection{solver}
During initialization, to get a solution the function \verb*|__solve__(self,y0,iter_limit)| is used. The function mainly loops through a seperate function \verb*|__F__(y)| until one of the following conditions is met:
\begin{enumerate}
	\item An equilibrium is apparent - The solution has remained the same for 3 iterations
	\item A two-cycle is apparent - The solution has oscillated between two colorings for 19 iterations
	\item A three-cycle is apparent - The solution has rotated between three colorings for 19 iterations. 
	\item The iteration limit is reached.
\end{enumerate}  
Once one of these conditions is met, the function returns the sequence of colorings, the number of iterations it took to terminate, the boolean variables saying whether or not it ended in an equilibrium, two-cycle or three-cycle, and the report, which is a string describing the orbit. 

The function \verb*|__F__(self,y)| is the main component of the solver. This function does exactly what is written in equation (1). Given an coloring \verb*|y|, it constructs a new coloring by the following process. For each vertex in the graph, it finds which colors are the most prevalent among its neighbors in the coloring \verb*|y|. If the argmax contains more than one color, the function either assigns the vertex to be the same color that it was or chooses between the colors in argmax according to the tie-breaking rule described in section 1.2. After each vertex is assigned a new color, the new coloring is returned. It is important to note that each coloring is stored simply as a vector of \verb*|int|s, not as a list of color objects. The strategies associated to each number is only assigned an actual color when the orbit is visualized.    
\subsubsection{Visualization}
Because this problem is best understood visually, visualization is obviously a very important part of this \verb*|Orbit| class. Within the class, the function \verb*|draw(self,n=1,dim=None)|, by default, draws the graph with the vertices colored by the last coloring in \verb*|self.solution| using the \verb*|nx.draw| methods (e.g. Fig. 1). If a different argument \verb*|n| is given then the method draws the last \verb*|n| colorings from self.solution in individual subplots which are arranged in the figure with dimensions given by \verb*|dim| (e.g. Fig. 2).

Seeing the orbit evolve through time can also be helpful for understanding so the method \verb*|animation(self)| in the \verb*|Orbit| class returns an animation of the colorings changing through time. It starts by defining a position so that the position of the vertices do not change in each frame then uses \verb*|FuncAnimation(fig,self.__animate__,farges=(pos,)...)| to create an animation.  The update function, \verb*|self.__animate__(self,framenumber,pos)| draws the edges and the vertices in the position given by \verb*|pos| then colors the vertices according to the coloring corresponding to the frame number. In order for each frame to use the same color to represent the same strategy each time, I create a color map by sampling the \verb*|hsv| color map with a uniform mesh the I use the function \verb*|__getcolors__(cmap,frame)| to make a vector of colors corresponding the the coloring. 
\subsection{Understanding Cliques}
The main tool to understand equilibria it observing and understanding their cliques so being able to identify and extract cliques is a crucial tool. The function \verb*|find_cliques(orbit)| is a function which takes an orbit object and returns a list of graphs, which are the subgraphs of the \verb*|orbit.graph| which represent cliques. For the case where the orbit ends in an equilibrium, this is easy. The function simply identifies all the colors present in that equilibrium coloring, and builds a list of subgraphs by using the \verb*|subgraph()| method of the graph class. 

For orbits which result in a two cycle, the method is slightly different. First it identifies the nodes which do not change color between iterations and divides those nodes into subgraphs in the same way as above. For the nodes that do alternate colors, the subgraph containing these nodes is separated into connected components using the \verb*|networkx.connected_components(graph)| method. Further analysis may require a more careful treatment of these two-cliques but this will suffice for our purposes. 
\section{Demo}
In order to demonstrate the capabilities of the code, the jupyter notebook \verb*|McAlisterProjectDemo.ipynb| showcases the objects and functions described above. 
\section{Next Questions}
Equipped with these tools, and the basis from which we can build more tools, we can start considering answering some interesting questions
\subsection{Stability}
The natural question to ask after identifying equilibria in a dynamical system is, ``are these equilibria stable or unstable" Although the ultimate goal is to find a graph theoretical condition for stability of a coloring, we need to be able to find equilibria and perturb them in order to start making observations.
\subsection{Examples and Counter Examples}
Similarly, there are other graph theoretical results which we have conjectured but require more observation of the system before we can prove. For instance, although this code does not disallow the emergence of three cycles, a three-cycle has never occurred during the course of this project. This has led us to conjecture that they are impossible (or they occur with probability zero). More generally, being able to solve the Initial value problem formulation of this game will help us test conjectured counter examples to future claims.
\subsection{Enumerating Equilibria}
Another way this code may be helpful is in describing how many cliques might exist at equilibria for a particular graph or a graph with certain parameters. Being able to find equilibria very quickly will help us measure this so we can start understanding trends. I suspect that the question "Find all the equilibria of this graph (up to recoloring)" cannot be solved in polynomial time, but having a way to start solving the problem for small graphs might make a general result possible. 
\subsection{Boundary Value Problem}
Lastly, the boundary value formulation of this problem is interesting to me because of the many applications. I have conjectured that, when a subset of vertices have fixed colors, the coloring which locally minimizes the number of edges between vertices with different colors is an equilibrium coloring of this game. Although the IVP is not an effective way to study this question, this collection of code gives us a basis to start testing algorithms to find equilibrium interpolations of boundary data.

\end{document}
